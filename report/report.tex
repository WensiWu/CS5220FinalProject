\documentclass[11pt]{article}
\usepackage{amsmath,amsthm,verbatim,amssymb,amsfonts,amscd, graphicx}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{float}
\usepackage{url}
\usepackage{titlesec}
\setcounter{secnumdepth}{4}


\graphicspath{{./times/}}
\topmargin0.0cm
\headheight0.0cm
\headsep0.0cm
\oddsidemargin0.0cm
\textheight23.0cm
\textwidth16.5cm
\footskip1.0cm

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


\begin{document}
\title{CS 5220\\ Final project - Computing Truss (?)}
\author{Marc Aurele Gilles (mtg79)\\ Wensi Wu(382) }
\maketitle

\section{Introduction}


\section{Problem Description}

We are computing truss TADATADA - can probably copy paste things from earls notes


\section{Numerical Method}

The truss computing problem can be written in the form

$$F_l(u)=0$$
where u is the truss, and F is a system of $n$ non-linear equations, where n depends on the number of nodes, elements and degrees of freedom(?), and l is the maximum load factor.

We solve this system of equation using a continuation method, starting at $l=0$, and incrementally increasing $l$ until it reaches the user specified maximum $l^{\star}$. Each $F_l(u)=0$ equation is solved by a Newton method iteration.
\\
That is we repeatedly solve $F_l(u_{t+1}) \simeq F_l(u_t) + S_l(u_t)*u_{t+1} =0$, where $T(u_t)$ is the Jacobian matrix at $u_t$, which in this problem is the same as the Stiffness matrix.\\

In other words, each iteration is a linear solve:
$S(u_t)*u_{t+1}=-F(u_t)$.

Most of the computation of this program is spent doing this linear solve. The stiffness matrix is very high dimensional for large structures, but also very sparse, a sparse solver is therefore needed.

\section{Setup: generating input structures}

As our objective is to speed up this computation and conduct scaling studies, we need to be able to generate input structures of variable sizes.
We wrote two scripts that generate two different type of input structures, a "chain" structure (see figure ~\ref{fig:chain}) , and a "pyramid" structure (see figure ~\ref{fig:pyramid}) .


\begin{figure}[h]
\begin{center}

\caption{A chain structure of 7 elements}
\includegraphics[width=8cm]{chain}
\label{fig:chain}
\\
The blue circles are the nodes, and the yellow bars are the elements
\end{center}

\end{figure}


\begin{figure}[h]
\begin{center}

\caption{A pyramid structure of 6 elements}
\includegraphics[width=8cm]{pyramid}
\label{fig:pyramid}
\\
The blue circles are the nodes, and the yellow bars are the elements
\end{center}

\end{figure}



For each structure we declare the position of each node, the position of each elements (as defined by a pair of nodes), the properties of each element (cross section area and ... ), and a load factor on each node.

These two different structure give rise to significantly different running time and sparsity patterns in the stiffness matrix, for a fixed number of elements. Indeed, the chain structure produces a stiffness matrix with a small dense band, which is not the case for the pyramid structure.
\\
add plots of sparsity structure

\section{Original code}
The original code reads in all of the parameter of the structure, and performs numerical method described above. At each iteration it generates the stiffness matrix (the Jacobian), and uses a linear solve that takes advantage of the sparsity pattern of the matrix. The matrix storage format is Skyline indexing (described below). The solver takes advantage of the regular access of the skyline indexing to perform a fast Cholesky-like factorization of the form $LDL^T$ (put source here and stuff). The original code is serial.


\subsection{Skyline}
Skyline is a sparse indexing format widely used in finite element codes for structural mechanics. A matrix in skyline format is two arrays: 
\begin{enumerate}

\item a value array which contains the values of the values between the "skyline" and the diagonal
\item a  pointer array for which the ith elements points to the index in the entry in the value array which contains the first non zero element in column i, and the last element is the size of the value array (+1 in case of the fortran-style indexing).

\end{enumerate}

\begin{figure}[h]
\begin{center}

\caption{Example of a matrix stored in skyline format}
\includegraphics[width=8cm]{skyline}
\label{fig:skyline}
\\
The blue slots are the skyline (stored), and the orange are the other elements stored in the skyline matrix format
\end{center}

\end{figure}
The matrix above in skyline format would be:

\begin{align}
values&=[1,5,1,0,4,6,7,4,0,-5]\\
pointers&= [1,2,3,6,8,11] 
\end{align}
Note that this uses the fortran style 1-based indexing

 It takes advantage of the fact that matrices that arise in this field are usually banded, symmetric positive definite matrices. Solving the system with such a matrix is usually (like in our code) by doing a sparse Cholesky-like decomposition. What makes the skyline indexing attractive is that the fill happening during the decomposition is only within the "skyline".
Though the skyline format is usually very efficient for small systems, it is known that the format can be less than ideal in bigger systems, where the "band" of the matrix grows large, and becomes itself  sparse.

\subsection{Timing of original code}
\subsubsection{Timing on the chain structure}

\subsubsection{Timing on the pyramid structure}

\section{New code}
Our new code translates the skyline format into a Compressed Sparse Row (csr) format and then uses the MKL sparse solver: pardiso.

\subsection{Compressed sparse row}

\subsection{Pardiso}


\section{Scaling studies}

\section{Conclusion}

\end{document}