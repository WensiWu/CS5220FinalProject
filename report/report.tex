\documentclass[11pt]{article}
\usepackage{amsmath,amsthm,verbatim,amssymb,amsfonts,amscd, graphicx}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{float}
\usepackage{url}
\usepackage{titlesec}
\setcounter{secnumdepth}{4}


\graphicspath{{./times/}}
\topmargin0.0cm
\headheight0.0cm
\headsep0.0cm
\oddsidemargin0.0cm
\textheight23.0cm
\textwidth16.5cm
\footskip1.0cm

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}


\begin{document}
\title{CS 5220\\ Final project - Computing Truss (?)}
\author{Marc Aurele Gilles (mtg79)\\ Wensi Wu(382) }
\maketitle

\section{Introduction}


\section{Problem Description}

We are computing truss TADATADA - can probably copy paste things from earls notes


\section{Numerical Method}

The truss computing problem can be written in the form

$$F_l(u)=0$$
where u is the truss, and F is a system of $n$ non-linear equations, where n depends on the number of nodes, elements and degrees of freedom(?), and l is the maximum load factor.

We solve this system of equation using a continuation method, starting at $l=0$, and incrementally increasing $l$ until it reaches the user specified maximum $l^{\star}$. Each $F_l(u)=0$ equation is solved by a Newton method iteration.
\\
That is we repeatedly solve $F_l(u_{t+1}) \simeq F_l(u_t) + S_l(u_t)*u_{t+1} =0$, where $T(u_t)$ is the Jacobian matrix at $u_t$, which in this problem is the same as the Stiffness matrix.\\

In other words, each iteration is a linear solve:
$S(u_t)*u_{t+1}=-F(u_t)$.

Most of the computation of this program is spent doing this linear solve. The stiffness matrix is very high dimensional for large structures, but also very sparse, a sparse solver is therefore needed.

\section{Setup: generating input structures}

As our objective is to speed up this computation and conduct scaling studies, we need to be able to generate input structures of variable sizes.
We wrote two scripts that generate two different type of input structures, a "chain" structure (see figure ~\ref{fig:chain}) , and a "pyramid" structure (see figure ~\ref{fig:pyramid}) .


\begin{figure}[h]
\begin{center}

\caption{A chain structure of 7 elements}
\includegraphics[width=8cm]{chain}
\label{fig:chain}
\\
The blue circles are the nodes, and the yellow bars are the elements
\end{center}

\end{figure}


\begin{figure}[h]
\begin{center}

\caption{A pyramid structure of 6 elements}
\includegraphics[width=8cm]{pyramid}
\label{fig:pyramid}
\\
The blue circles are the nodes, and the yellow bars are the elements
\end{center}

\end{figure}



For each structure we declare the position of each node, the position of each elements (as defined by a pair of nodes), the properties of each element (cross section area and ... ), and a load factor on each node.

These two different structure give rise to significantly different running time and sparsity patterns in the stiffness matrix, for a fixed number of elements. Indeed, the chain structure produces a stiffness matrix with a small dense band, which is not the case for the pyramid structure.

\begin{figure}[H]
\begin{center}
\caption{Sparsity structure of the stiffness matrix generated from the pyramid structure}
\includegraphics[width=20cm]{pyramid-sparsity.png}
\label{fig:pyramid-sparsity}
\\
\end{center}

\end{figure}

\section{Original code}
The original code reads in all of the parameter of the structure, and performs numerical method described above. At each iteration it generates the stiffness matrix (the Jacobian), and uses a linear solve that takes advantage of the sparsity pattern of the matrix. The matrix storage format is Skyline indexing (described below). The solver takes advantage of the regular access of the skyline indexing to perform a fast Cholesky-like factorization of the form $LDL^T$ (put source here and stuff). The original code is serial.


\subsection{Skyline}
Skyline is a sparse indexing format widely used in finite element codes for structural mechanics. A matrix in skyline format is two arrays: 
\begin{enumerate}

\item a value array which contains the values of the values between the "skyline" and the diagonal
\item a  pointer array for which the ith elements points to the index in the entry in the value array which contains the first non zero element in column i, and the last element is the size of the value array (+1 in case of the fortran-style indexing).

\end{enumerate}

\begin{figure}[h]
\begin{center}

\caption{Example of a matrix stored in skyline format}
\includegraphics[width=8cm]{skyline}
\label{fig:skyline}
\\
The blue slots are the skyline (stored), and the orange are the other elements stored in the skyline matrix format
\end{center}

\end{figure}
The matrix above in skyline format would be:

\begin{align}
values&=[1,5,1,0,4,6,7,4,0,-5]\\
pointers&= [1,2,3,6,8,11] 
\end{align}
Note that this uses the fortran style 1-based indexing

 It takes advantage of the fact that matrices that arise in this field are usually banded, symmetric positive definite matrices. Solving the system with such a matrix is usually (like in our code) by doing a sparse Cholesky-like decomposition. What makes the skyline indexing attractive is that the fill happening during the decomposition is only within the "skyline".
Though the skyline format is usually very efficient for small systems, it is known that the format can be less than ideal in bigger systems, where the "band" of the matrix grows large, and becomes itself  sparse.

\subsection{Timing of original code}

Below is the relevant part of a result of a timing of the original code on the test case of pyramid with size of base 200 using amplxe.
\begin{center}
 \begin{tabular}{||c c c ||} 
 \hline
 Function & Description & CPU Time \\ [0.5ex] 
 \hline\hline
 solve & Sparse linear solve & 32.560s  \\ 
 \hline
 intel memset  & allocates memory & 0.273s  \\
 \hline
 printf fp & prints to file & 0.132s  \\
 \hline
 stiff & computes stiffness matrix & 0.104s  \\
 \hline
  forces & computes residual forces & 0.078s  \\[1ex] 
 \hline
\end{tabular}
\end{center}

It is clear that most of the time is spent in the function solve, which performs the sparse linear solve, therefore we focused on using a more efficient sparse solver.


\subsubsection{Timing on the chain structure}

\subsubsection{Timing on the pyramid structure}

\section{New code}
Our new code translates the skyline format into a Compressed Sparse Row (csr) format and then uses the MKL parallel sparse solver: pardiso. On the test case 

\subsection{Compressed sparse row}

\subsection{Pardiso}
\subsection{Timing comparisons}
Below is a figure showing  the comparisons of running time between the original solver and the pardiso solver with standard settings on the chain structure. \\

We observe that on the chain structure, both solver are very fast (about 1 second for a structure with 30.000 elements, but the original solver is slightly better. This is likely due to the fact that the original solver is very efficient on this system generated by the structure. Indeed as observed earlier the stiffness matrix in this case have a small but dense band, which is where the solver using the skyline format excels.


\begin{figure}[H]
\begin{center}

\caption{Comparison of running time on pyramid structures}
\includegraphics[width=12cm]{chainplot}
\label{fig:pyr_comp}
\end{center}
\end{figure}

Below is a figure showing  the comparisons of running time between the original solver and the pardiso solver with standard settings on the pyramid structure. \\

Contrary to the chain structure, on the pyramid structure the pardiso solver is much faster. This is likely due to the fact that the skyline format keeps a very high number of zeros, and therefore performs a lot of unnecessary arithmetic. Indeed, for the case where we have a 40.000, over $98\%$ of the entries saved by the skyline format are zeros.


\begin{figure}[H]
\begin{center}

\caption{Comparison of running time on pyramid structures}
\includegraphics[width=12cm]{pyrplot}
\label{fig:pyr_comp}
\end{center}
\end{figure}



\section{Scaling studies}

\section{Conclusion}

\end{document}